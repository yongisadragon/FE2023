0514 DP특강

Ajax 시작전

HTTP/HTTPS
클라이언트와 서버간 리퀘스트와 리스폰스를 가능하게 하는 프로토콜임.
프로토콜은 쉽게 말하면 규칙임. HTTPS의 S는 Secure. 좀더 안전하게 암호화 시킨 프로토콜.

XML
서버가 클라이언트한테 res를 줄때 형식을 XML/JSON 형식으로 전달한다. 
XML은 tag형식이고, 가독성이 떨어짐.
추세인 JSON은 배열 객체 형식이다.

그렇다면 Ajax는?
클라이언트와가 서버에게 Ajax를 통해 req를 한다고 보면됨. 그 방법임. 그 종류는 XHR, fetch, axious, $.ajax가 있음. a나 form 태그를 통해 요청 할때에는 화면의 반짝임이 있었음. 구식방법.
이 주고 받는 과정을 HTTP를 이용한다라고 보면된다.

XHR은 (XMLHttpRequest) 서버와 비동기 통신을 가능하게하는 여러 기능들을 가진 JS객체. 브라우저 API에서 제공하는 객체임.

$.ajax 는 잘 안쓴다. 끝

fetch는 XHR(이벤트 기반)성능에는 문제가 없었으나 코드가 길고 가독성이 좋지 않음. Promise(Promise기반)객체를 반환함. 
fetch는 Promise 기반으로 구성돼있어 비동기 처리 프로그래밍 방식에 잘맞는 형태엠. then과 catch로 체이닝 할 수 잇음.
fetch는 함수 처럼 바로 실행 가능 then을 통해 데이터를 가져오고, 체이닝을 통해 데이터를 .json()을 통해 JS객체로 변환해줌. catch는 오류를 잡아줌.
response.ok - HTTP상태 코드가 200과 299사이일 경우 true
Promise는 비동기 통신을 매우 쉽게 해줌^^
then도 머리아프다 -> async-await

axios는 리액트라이브러리를 통해 서버에서 데이터를 가져오는 방법.
Promise API 사용. 
axios와 fetch의 차이이자 axios의 장점은 .json()을 거칠 필요가 없다는 것이다. axios는. then을 한번만 해서 오면 됨.


함수 선언문
-직관적 형태
-전역 스코프

함수 표현식
let, const를 통한 함수표현식의 경우는 함수이름 생략할 수 있지만 이름을 지정해주는게 좋음. 
단일문일 경우 리턴과 중괄호 생략가능.

표현식vs선언문

표현식은 해당줄에 도달될때에만 .. 호출된다.
자바스크립트는 소스코드를 위에서 아래로 한줄 씩 실행(인터프리터)하는데, 표현식은 호출이 함수보다 올라가면 레퍼런스 에러가 뜸.
선언문의 경우 호출코드를 함수보다 올려도 호출됨. 
내부 알고리즘이 초기화 단계에서 코드내 모든 변수 선언과 함수 선언문을 찾아내서 호이스팅 하기 때문에. 

차이.
함수 선언문은 함수를 선언하는 구문으로, 전역 스코프나 함수 스코프 내에서 선언될 수 있으며, 호이스팅에 영향을 받습니다. 반면 함수 표현식은 변수에 함수를 할당하는 표현식으로, 선언문과 달리 블록 스코프에 영향을 받으며, 호이스팅은 변수 선언만 되고 할당은 호이스팅되지 않습니다.

시멘틱(semantic)은 '의미론적'이라는 의미
프로그래밍에서의 시맨틱은 코드나 프로그램의 의미론적 내용을 표현하고 전달하는것
코드의 가독성과 이해도를 높힌다.
HTML 태그를 구조적 의미적으로 적절하게 사용해서 문서의 구조와 의미를 명확하게 표현하는 것. 
타입스크립트는 JS 변수와 함수에 타입을 명시함으로써 시맨틱으로 더 강화할 수 잇음.
CSS에서는 시맨틱한 선택자와 속성을 사용해서 코드의 가독성과 유지보수성을 개선할 수 있음.

시맨틱 마크업의 이점
검색 엔진이 마크업의 내용을 페이지의 검색 순위에 영향을 끼칠 중요한 키워드로 간주함.
시각 장애등, 스크린 리더로 페이지를 탐색할 떄 마크업을 푯말로 사용함.
채워질 데이터의 타입을 개발자가 설정할 수 있음. -> 목록형이냐 순서가 있는지,, 정의가 나열되는지.. 캡션이 필요한 이미지인지.. 사이트 전체에 헤더 푸터가 더 필요한지.. ?
페이지 탐색을 마크업을 통해한다고 했을때, 태그는 중요한 역할을 한다. 

header 전적 사이트의 헤더를 정의. 다른 위치에도 사용가능(ex 모달 섹션내에서 header를 정희할 수 잇음.)
nav 현재 페이지 내부나 다른 페이지로의 링크를 그룹화하는데 사용되는 섹션. 
main 문서의 주요 콘텐츠. 가장 중요한 콘텐츠 영역을 마크업 할 수 있다. 한 문서에서 유일한 내용이어야 함.
section 메인안에서 구획을 나눌때. 헤딩이 존재해야함. 페이지 구조를 이해하는데 효과적.
aside 주요컨텐츠와 별개로 부가적인 정보를 제공하는 영역. 광고, 기타링크, 사이드 카테고리같은 .. 주요 콘텐츠를 보완하거나 부가적인 정보 외부 컨테이너로 사용될 수도 있음. 메인컨텐츠와 연관이 있는 정도..
dialog 최신 브라우저에서 모달, 대화 상자, 사용자와의 상호작용을 위한 독립적인 UI
template 혼자 안쓰임. 자바스크립트가 동적으로 채워지거나 할 때 함께쓰임. 마크업은 DOM내에 있지만 렌더링은 안됨. 브라우저에 표시되지 않음. DocumentFragment와 함께 쓰이곤함.

함수는 하나의 행동만 해야한다.(호출시 여러 값이 나와버리면 재사용, 유지보수 힘듬)
함수에서 조건식 사용을 지양해야함.(쉽진않음, 삼항, 논리, 단축 평가 등을 사용)
함수의 인자는 2개 이하가 이상적이다.

----------
0515 수업

useEffect(()=>{}) 는 state가 변할때, ()=>{}내부 함수를 실행한다.리액트 컴포넌트가 가지고 있는 상태가 바뀌면 실행해주는..


useMemo
떤 부하가 생기는 함수를 반복해서 작업할 때 기억해두었다가 사용하는 기법을 말합니다. 렌더링이 될 때 이전에 작업해두었던 결과값을 가지고 있다가 반영해주는 것이죠.
버튼을 누름 -> 함수 실행 -> setState함수 실행 -> 리렌더링 -> App함수 실행


useRef 초기값
일반적으로 useRef를 사용하여 DOM 요소를 참조할 때, 초기값으로 null을 사용하는 것이 권장되는 이유는 다음과 같습니다:

초기값을 null로 설정하면 useRef 객체는 초기에 어떤 DOM 요소도 참조하지 않으므로, 초기 렌더링 시 오류가 발생하지 않습니다.
나중에 DOM 요소를 참조할 때 해당 요소를 할당할 수 있으므로, 동적인 상황에서도 유연하게 DOM 요소를 참조할 수 있습니다.
빈 문자열을 사용하더라도 현재 코드에서는 동작에는 문제가 없을 수 있지만, useRef의 관례를 따르고 초기값으로 null을 사용하는 것이 더 일반적이고 안전한 방법입니다.