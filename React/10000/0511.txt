퍼블릭 폴더의 용도는 빌드할 때 기준점.. 정직한 경로 생파일 이미지가 많다면 퍼블릭에 넣자.. import없이 바로 부를 수 있는 장점은 있..
src 안에 있는 파일은 난독화 최적화 ..난수가 곁들여져 표현됨(웹팩에 의해)

public 폴더에 파일을 넣는 경우
장점:
public 폴더 안에 있는 파일들은 빌드된 애플리케이션에 직접 접근할 수 있습니다. 이는 외부에서 애플리케이션을 사용할 때 유용할 수 있습니다.
이미지나 폰트와 같이 변하지 않는 정적 파일들은 public 폴더에 넣으면 빌드할 때 자동으로 복사되기 때문에, 파일 경로를 매번 수정할 필요가 없습니다.
단점:
public 폴더 안에 있는 파일들은 빌드 시에 그대로 복사되기 때문에, 파일 크기가 커질 수 있습니다. 이는 애플리케이션의 초기 로딩 시간을 늘릴 수 있습니다.
public 폴더에 넣은 파일들은 컴파일되지 않기 때문에, 파일 내용에 대한 변환 작업을 수행할 수 없습니다.

src 폴더에 파일을 넣는 경우
장점:
src 폴더 안에 있는 파일들은 웹팩과 같은 번들러에 의해 컴파일되어, 최적화된 형태로 빌드됩니다. 이는 파일 크기가 줄어들어 초기 로딩 시간을 줄일 수 있습니다.
src 폴더 안에 있는 파일들은 모듈로서 임포트할 수 있기 때문에, 코드의 가독성과 재사용성이 좋아집니다.
단점:
src 폴더 안에 있는 파일들은 외부에서 접근할 수 없기 때문에, 이를 사용하려면 별도의 작업이 필요합니다. 예를 들어, 이미지를 사용할 때는 src 폴더 안에 넣고, 이미지 경로를 import 문으로 지정해야 합니다.
src 폴더 안에 있는 파일들은 번들링되기 때문에, 변하지 않는 정적 파일이라면 파일 크기가 커질 수 있습니다. 이 경우에는 public 폴더에 넣는 것이 더 효율적일 수 있습니다 

button onClcik말고 form에 onSubmit을 쓰면 좋은점. 이것도 이벤트리스너이기 때문에, 온서밋을 통해 발생한 이벤트 객체..가 있는데 그걸 log로 까보면 알겠지만 그 안에 target정보가 있고, 그건 form에서 관리하는 인터랙티브 요소들(이를테면 버튼이나 인풋에 대한)에 대한 정보들이 들어 있어서 사용할 수 있다.

제출 안 하신 분들 중에서도 좋은 분이 있다고 믿습니다 ㅋㅋ

오늘의 순서
순수 HLTML CSS 제작한다. 리액트 폴더 구조에 붙여넣기 한다. 이미지는 폴더를 옮겨놓고 웹팩 문법으로, 경로로 불러오고 html은 해당 jsx에 각각 구획별로 나눠서 복붙, css는 src-각 jsx에 해당되는 css만들어서 복사 붙여넣기.

리셋 css 는 index.css 만들어서 넣어줌

jsx에선 class 이름과 url이미지 웹팩으로 import해서 변수처리  해주기 까먹지말자.
각 css에는 이미지 경로 수정해주기. img폴더를 어디에 뒀느냐에 따라 ../../ 고쳐주기




  URL복사 방법 1.
  function clip() {
    var url = "";
    var textarea = document.createElement("textarea");
    document.body.appendChild(textarea);
    url = window.document.location.href;
    textarea.value = url;
    textarea.select();
    document.execCommand("copy");
    document.body.removeChild(textarea);
    al
  }
------------------------
  URL복사 방법 2.
+ navigator.clipboard API를 사용하여 클립보드에 텍스트를 복사하는 법 질문과 답변

Q. 리액트 컴포넌트 안의 버튼에  onClick시 함수를 넣으려고하는데,   왜 1번 처럼 안쓰고, 2번처럼 써야 작동해?
1.    <button type="button" onClick={handleCopyClipBoard('응 속았어')}>
2.   <button type="button" onClick={()=>{handleCopyClipBoard("응 속았어")}}>

A. 1번 코드에서 onClick 이벤트에 함수 호출 결과를 전달하고 있습니다. 이렇게 하면 버튼이 렌더링될 때 함수가 즉시 호출되고, 이벤트 핸들러는 함수의 반환값이 아니라 undefined을 받게 됩니다. 따라서 이벤트 핸들러가 작동하지 않습니다.

2번 코드에서는 함수 호출 대신에 새로운 함수를 onClick 이벤트 핸들러로 전달하고 있습니다. 이 함수는 클릭 이벤트가 발생할 때 실행됩니다. 이 방식으로 하면 버튼을 클릭할 때만 함수가 실행되므로 의도한 동작을 수행할 수 있습니다.

따라서, 2번 코드처럼 새로운 함수를 onClick 이벤트 핸들러로 전달하는 것이 좋습니다.

window.location.href는 현재 페이지의 URL을 나타냅니다. 이 값을 navigator.clipboard.writeText() 메서드의 인수로 전달하여 클립보드에 복사할 수 있습니다. 따라서 handleCopyToClipboard() 함수 내부에서 이 값을 사용하여 클립보드에 현재 페이지의 URL을 복사하도록 구현할 수 있습니다.


Q. 작업이 실패하는 경우는 도대체 어떻게 발생하지?
A. navigator.clipboard.writeText() 메서드가 실패하는 경우는 사용자 브라우저 설정에 따라 다를 수 있지만, 일반적으로 다음과 같은 상황에서 실패할 수 있습니다.

사용자가 클립보드 접근 권한을 거부한 경우
브라우저에서 클립보드 작업이 지원되지 않는 경우 (예: 일부 오래된 브라우저)
클립보드 작업이 비활성화된 경우 (예: 일부 브라우저에서 보안상의 이유로 일부 웹사이트에서 클립보드 작업을 비활성화할 수 있음)
위와 같은 경우 navigator.clipboard.writeText() 메서드는 Promise 객체를 반환하면서, 작업이 실패한 이유를 에러 객체로 전달합니다. then/catch를 사용하여 에러를 처리하면, 사용자가 클립보드 접근 권한을 거부했거나 브라우저에서 클립보드 작업이 지원되지 않는 경우와 같은 실패 상황에 대한 에러 처리를 할 수 있습니다.