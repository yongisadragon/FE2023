-웹 기술을 사용 웹 브라우저(를 포함한 다양한 환경)웹뷰 네이티브 바이너리,,
에서 사용하는 웹사이트나 웹 어플리케이션을 만든다.
-개발, 디자인, 마케팅 다양한 동료와 함께 사용자가 공기처럼 사용하는 제품을 만든다. <배려> <공감> <커뮤니케이션>
-문제를 해결하는 제품을 적정 기술로 구현해서 빠르게 출시
-문제: 사용자에게 필요한 것 = 사용자의 목표(Goal) 
-러스트 웹어셈블리블리
-인간 휴먼팩터 공통 습관을 공부하면 좋다. fitts' law
-디자인 패턴 공부 mobbin / designvault.io / wwit
-느린 것 같아 보이지 않는 UI.
-로직이나 코어를 잘 개발..
-UI의 숙명 작은 변경 + 사용자에게 바로 노출되는 버그
-codewhisperer / 코파일럿 
-disquiet 아이디어
-생성 AI AGI(Artificial general intelligence)특정분야에 훈련된 ai보다 어떤 지식도 중간이상 제공해주는 ai가 대세.
-AGI는 직업을 대체하기보단, 작업은 대체할 것이다.
-문제를 인식하는 방법. 한번더 생각해볼것.
-백엔드 랭귀지의 선택보다 이른바 컴퓨터 시스템 데이터 베이스 오퍼레이션 .. 등 내가 뭘 재밌어하는지 보세영
-면접팁..내가 얼마나 좋은 개발자인지 설명하려고 하지마세여. 나를 이해할 수 있도록 근거를 줘야함. 내가 왜 이 직무에 적절한 사람인지 타당한지 (경험, 학습 등)
-내 이력서가 잘 작성된지보다, 면접관들이 뭘 물어볼까. 면접관들의 문제를 해결해 줄 수 있을까.
-전공자에 비해 뒤쳐진 과목들을 어떻게 보충하고 있는지.
-본인 소개나 장단점을 말할 때 어떤 식으로 말해야 할까요? 자기 자신을 나타내는 단어5개. 추려서 짧게. 싸가지 없이 보일 정도로 짧게 ..신중함 낭만 효율 ? ? 
-랭귀지를 공부한다.. 라고 할땐 파이썬


---
이종찬 강사님 
-
-margin은 공간이다. 마진이 늘거나 줄면 보여지는 디자인(컨텐츠) 그대로처럼 보이지만 컨텐츠가 차지하고 있는 공간이 달라짐.. 브라우저를 속였다.? 
브라우저가 인식하는 범위는 컨텐츠의 <보여지는 디자인>의 공간이다. 설령 네거티브 마진을 준다고해도 
..컨텐츠가 보여지는 건 그대로지만(비주얼) 공간을 차지 하는 개념은 아니다. 그래서 위나 아래 컨텐츠들도 말려 내려가거나 올라간다. 즉, <보여지는 디자인-껍데기> <차지하고 있는 공간-알맹이>이 따로이다. 
마진이 마이너스 값이 가능하다.. 라는건 position과 구분되는 아주 중요한 점이다. *남용은 역시 금지* 
네거티브 마진의 포인트는 보여지는 것은 그대로, 차지하는 실제 공간은 변화가 일어나는 것. 겹치는 카드 디자인 등..

가령 header아래 content가 있다고 치면, content에 margin-top: -50px;을 주면 헤더 위를 덮는다. 똑같이, header-bottom: -50px;을 줘도 결과는 같아 보인다. 그러나 차지하고 있는 공간은, 서로 상이한 상태이다. 

나중에 작성된 마크업이 위로 오는게 원칙.(예: A B C 박스 순.) 근데 이상태에서 b박스 양쪽에 네거티브 마진을 줘서 A박스 위에 B 박스, 그리고 C박스일 경우, B박스가 맨위로 튀어나올려면 position에 스태틱이 아닌 값이 들어가면 튀어나온다. zindex에 상관없이.. 결과적으로 move가 아니라 차지하는 공간이 달라진 것이다.

width: auto의 의미는 부모가 제공해주는 컨텐츠 영역(컨테이닝 블럭)만큼을 따른다.
네거티브 마진의 꽃:
블럭레벨, 너비가 auto이고, 네거티브로 마진이 들어가면 껍데기만 늘어나는 결과나 나옴. 

min-height 컨텐츠가 없어도 기본적인 높이값을 유지.

----
위치를 이동 시키는건 (네거티브 마진은 이동이라기 보단 차지하는 공간을 변경해주는 것이고) position이랑 transform등이 있다. 
position의 이니셜벨류는 static이다. relative를 부여하면 마크업 순서에 상관없이 튀어 나온다. 얘는 자기가 주도권이 없다.

absolute가 되면 붕 뜨기 때문에. 뒤따라 오는 컨텐츠는 뒤로 숨어버린다. 이게 앱솔루트의 기본적이 성격. left top 0 (참고로 left top의 이니셜 벨류는 auto) 을 하면 뷰포트의 구석으로 간다.(전체창) 최초에는 뷰포트 기준인 것이다. 컨테이닝 블럭이 뷰포트가 그 역할을 하는 것이다. 말그대로 창크기. 스크롤 하면 올라가고. 보는 화면(뷰포트)가 기준인 것임. (realtive가 없을 시, body가 기준 아님.)

이전에 앱솔루트 일때는 기본 컨테이닝 블럭이 뷰포트라고 말한 바 있다. 만약 상위 마크업에 아버지 태그가 있다면 직계 부모에게 '스태틱이 아닌 값 (relative등, 그럼 부모한테 absolute줘도 돼? 그럼 상위 마크업도 도망치겠지.. 다른곳으로 상위에 relative가 걸려있거나 뷰포트거나. 그래서 아무 변화를 안일으키는 relative를 주는게 낫지.)'을 주면 그 부모 태그는 새로운 컨테이닝 블럭(부모가 제공해주는 컨텐츠 영역의 크기)이 되는 것이다.
그렇다면 할아버지도 relative가 있다면? ->가까운 것에 적용이 된다. 단, 아버지엔 없고 할아버지에 relative가 있다면 할아버지가 기준이 됨.

absolute가 걸린 상태에서 left, top을 50%주면 가운대로 정렬되는데, 그건 왼쪽 위 꼭지점이야. 그래서 transform: translate(-50%, -50%);을 해주지.cen스니펫 참고. 그런데 transform: translate(50%, 50%); 이건. 네거티브 마진으로도 가능해. 
margin-left: -50%;, margin-top: -50%; 같은 조선시대적 방법이 있다. 하지만 쓸일은 있다고 한다.

absolute의 또다른 특성이 있다. div태그(블락)에 absolute가 되면 인라인이 된 것 마냥(인라인 아님) 컨텐츠(텍스트 등)가 차지한 영역만큼을 차지하게 되는데, 이를테면(relative가 할아버지에게 있다고 치고)
left right top 0을 주면 이건 컨텐츠가 가진 너비 영역을 최대로 가지게 해주는 것이, 마치 블록 레벨 엘리먼츠 width auto처럼 다시 모양을 형성한다.(정확하게 말하면 inline-block이 된다. absolute와 fixed를 주면 인라인블록이 된다. 하지만 relative를 준다고 인라인블록 변하지 않고 고유의 display 속성을 유지) 이상태에서 적당한 width값을 주고 margin 0 auto;를 하면 블록 요소가 중간 정렬하듯 정렬을 해준다.
만약 right를 안 부여한 상태라면, 방금 블럭 처럼(보이는) margin에 의한 정렬이 작동하지 않는다.
즉, absolute, top right bottom left 0을 주면 꽉 찬다(relative에) 이것의 단축속성은 inset: 0;.과 같다. 
left: 10;
top: 10;
right: 10;
bottom: 10;
= inset: 10; (네거티브도 됨. 마진과 비슷하게 껍데기가 커지듯 작동됨)


---
flex!!중요
전통적으로 container(부모)안에 flex-items(자식)들에게 가로배치 하려면, 플롯이나, 인라인등을 고려할 수있다. flex는 부모(container)에 적용을 해주는 것이다. display: flex;는 container(부모)에 적용한다.

처음보게되는 장면은 margin: right;상태. (예를 든 상황은 items가 3개)'사용 가능한 공간을' 'n명'이 나눠갖는 쉐어 하우스를 떠올려보자. item들중 하나(뭐 코로나에 걸렸다고 치고)를 오른쪽으로 밀어버리려면, 선택자해서 margin-left: auto;로 하겠죠. 중간애한테 margin: 0 auto;를 주면 양쪽에들이 밀려남.

margin은 누구에게 어떤 방향으로 주느냐에 따라 밀려나는 것이 달라짐. 첫번째 item에 마진 left:auto ;
마지막 item에 마진 right:auto;하면 부모에게 justify-contents: center; 와 같은 모양새가 된다. flex에서 왠 마진이야기냐! 라고 하면 지켜보자.  

각 방의 크기를 지정해주는 것은 flex-basis: auto; 이다. 내부 자식 컨텐츠 크기만큼 잡힌다.
flex grow의 이니셜벨류는 0이다=basis의 크기만큼 커지겠다.. grow:1  basis값에 grow값이 더해져 남는 공간을 다쓰겟다. grow는 basis값에 더해지는거다. basis auto가 기본값이고, auto는 컨텐츠 크기만큼이다. 만약 3개에 다 grow:1을 주면 균일하게 남는 공간을 준다. 그리고 그 너비는 같다.(컨텐츠 크기가 각 동일하다고 했을때), 셋중하나라도 컨텐츠 크기가 다르다고 한다면, 그 너비는 커진다(basis가 auto이기 때문에 컨텐츠를 인식해서 커짐).

shirink의 초깃값도 1이다. 방이 많아져도 이건 모두 고통 분담한다는 이야기. 축소 수축에 대한 이야기. 수축이 가능하게 돼있는 것. basis를 200으로 했지만 상황이 여의치 않으면 줄이겠다. 방사이즈(item). 개구리가 사는 그 방사이즈가 일정 개수를 넘으면 이탈해버리는데 그건 왜그럴까? 아이템들이 가지고 있는 property중에 'min-width'가 숨어있다. 이건 플렉스 items에 auto로 지정되어있다. 이것이 의미하는 바는 내부의 컨텐츠 '만큼'이다. 방의 크기(items), item의 너비는 내부 컨텐츠에(자식의 너비만큼) 강제된다. 자식의 너비(컨텐츠)보다 작아질 수 없도록 min-width가 막고있다. 이말인즉슨 min width를 0으로 지정하면, 방이 늘어나도 끝없이 container에 갇힌다. 빠져나가지 않는다.

그렇다면 basis값이 0이되면? 줄거나하지않고 그대로이다. 마치 width처럼 쓰이는데, 사이즈가 줄어드는게 아닌가? 라고 생각해줄 수 있지만, 아까 말했듯이 min-width가 auto로 숨어있다. 둘다 0을 하면 컨텐츠가 비로소 item박스를 빠져나가버려서 터져버린다. 이 상태에서 grow1하면 items들은 균등하게 3등분되어 container에 찬다. basis와 숨어있는 min-width값의 관계를 잘 생각하자.

justify-contents 와 align-items 는 부모입장에서 주는 값이다. 

자, 다음은 방 중 하나의 높잇값을 높이면 부모의 height는 물론 다른 방들도 늘어나는 현상을 볼 수 있는데, 부모의 align-items가 지정이 되어있지 않으면, 그것의 초깃값이 normal(stretch)로 설정되기 때문이다. center등 다른값(flex-start 등)을 주면 높이값을 준 방 빼곤, 높이가 달라지며 세로 정렬이 되는것을 볼 수 있다. justify-contents의 초깃값은 flex-start이다. 순서를 바꾸는건 flex-direction: ~ reverse;.
flex먹였는데 이미지들이 쫙 늘어난다-> flex 속성의 기본 align-items: stretch;를 의심하자. flex start로 변경하든 center하든! 맘대로하세요.

추가적으로 방들에 각각 margin을 줘서 원하는 위치에 옮길 수 있다.