<!DOCTYPE html>
<html lang="ko-KR">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>title name</title>
</head>

<body>
  <script>
    let a = [1] // 비교할 대상: 0
    let b = [3, 2] // 비교할 대상: 1 
    let c = [3, 2, 1] // [2,3,1] => [2,1,3]
    let d = [4, 3, 2, 1] // [3,4,2,1] => [3,2,4,1] => [3,2,1,4] 비교: 3
    // 정렬이 처리되는 과정이 마치 거품같아 버블 정렬이라고 함. 비교횟수 : length -1

    let myArr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
    let myArr2 = [10, 9, 8, 5, 6];
    let myArr3 = [1, 1, 2, 3, 4, 5, 6, 8, 9, 10]

    function bubbleSort(arr) {
      for (let index = 0; index < arr.length - 1; index++) {
        // 원소의 위치를 변경해줍니다.
        if (arr[index] > arr[index + 1]) { //만약 비교값이 사실이라면, 두개 위치 switching
          // 방법1. 변수에 옮겨놓고 스위칭
          // let temp = arr[index]; 
          // arr[index] = arr[index + 1];
          // arr[index + 1] = temp;

          // 방법2. 구조분해 할당으로 두개 위치 바꿔줌
          [arr[index], arr[index + 1]] = [arr[index + 1], arr[index]]

        }
        console.log(arr); //변화과정 볼 수 있음.
      }
      return arr;
    }

    //let result = bubbleSort(myArr); // 얘 계속 돌리면 결국 오름차순 됨;

    //그렇다면 이 아이디어에 착안해 오름차순을 구현해보자!
    function bubbleSortAdvanced(arr) {
      for (let index = 0; index < arr.length - 1; index++) {
        for (let index2 = 0; index2 < arr.length - 1; index2++) {
          // 원소의 위치를 변경해줍니다.
          if (arr[index2] > arr[index2 + 1]) {
            [arr[index2], arr[index2 + 1]] = [arr[index2 + 1], arr[index2]];
          }
          console.log(arr);
        }
      }
      return arr
    }

    // let result2 = bubbleSortAdvanced(myArr);

    // 좀더 불필요한 과정을 없애기 위한 버블 함수
    function bubbleSortAdvanced2(arr) {
      let counter = 0;
      for (let index = 0; index < arr.length - 1; index++) {
        // 정렬이 필요한 배열인지 상태를 저장합니다. true일때, 비교가 필요하지 않은 배열이다라고 설정
        let isSorted = true;
        // 1. 이미 맨끝으로 간 원소만큼 배열길이에서 빼줘야 불필요한 비교를 줄일 수 있음.
        for (let index2 = 0; index2 < arr.length - 1 - index; index2++) {
          // 2. 인접 원소랑 비교가 필요 없을 경우(이미 정렬이 됐을 경우), 비교를 하지 않고 for문을 끝내야할 필요가 있음 
          if (arr[index2] > arr[index2 + 1]) {
            [arr[index2], arr[index2 + 1]] = [arr[index2 + 1], arr[index2]];
            isSorted = false;
          }
          counter++;
          console.log(arr);
        }
        // isSorted가 true일때,(비교가 필요하지 않을때) for문이 딱 필요한 경우에만 동작한다. 아마도 이미 정렬된 배열을 넣었을 경우, 배열의 길이-1 만큼 최소한의 비교만 할 것임.
        if (isSorted) break;
      }
      console.log('counter:', counter);
      return arr;
    }

    bubbleSortAdvanced2(myArr);

  </script>
</body>

</html>

<!-- Alabama Shakes - Sound & Color -->