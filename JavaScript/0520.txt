객체 지향 프로그래밍

데이터와 그것을 다루는 함수를 객체라고 불리는 하나의 장소에 모아둣것.
로봇을 만들듯 머리 팔 다리 컴포넌트 등..

깔끔하고 알아보기 쉽다.
메모리를 절약한다.
유지보수가 용이하다.
재사용성이 높아진다.
부모의 프로퍼티 메서드를 재사용해서 상속을한다. 상속을 이요해서 코드의 중복을 제거함.


인캡슐레이션 데이터와 해당 데이터를 조작하는 메서드들을 하나의 단위로 묶는 것을 말합니다.
근데 이런 객체가 수백 수천개가 되면 악영향이 생김.
객체는 다 다르다. 똑같은 객체를 만드는게 사실 의미가 없다. 하지만 기능에 해당되는 메서드는 객체마다 같은 방식으로 동작한다.
어차피 같은 메서드를 사용한다면, 메모리 낭비가 일어나고.. 흠 메서드가 공통되는데 방법이 없을까? -> 생성자 함수.. 이용

prototype?
new키워드를 통해 생성자 함수를 생성하고, 객체를 대량생산하는 가운데, 
prototype은 메소드를 인스턴스들이 공유하도록 하여 메모리 공간도 절약 가능.
객체마다 똑같은 함수를 작성해야되는 반복을 줄인다.
인스턴스들이 메서드를 공유하는 어떤 공간.
근데 단점은 없음?
지저분하다.객체안에 있던 메서드가 prototype과 함께 외부로 빠져나옴.. 근데 보니까 못생겼음. 옹기종기 모여있던 객체는 어디로..
보편적인 객체지향 코드의 모습과 차이가 있음. 오직 생성자 함수(인스턴스)에서만 의미를 가지게 됨.. 

드디어. class 등장. class는 C++ 이래 공통적으로 사용됨. JS도 2015년 class 개념을 받아들이고 나서 코드 모습이 전통적인 객체지향형의 모습을 가지게 됨.

인스턴스를 생성할때 자동실행되는 constructor가 있구요
이런식으로 상속 가능~
class 자식클래스 extends 부모클래스{
	constructor(){
	super();
	this.name=..
	}
...
}

...
const 인스턴스 = new 자식클래스 
로 확장한다.. 

리액트 이런거 본적 있죠 
이거 this등 쓰일때 대비해서? 대비해서가 맞는 표현인지 모르겠는데 화살표 함수를 의도적으로 쓴거임. this가 버튼 가르키도록
<button onClick= () => {}> ..</button>


캔버스api를 쓰면 화면에 이미지를 비트맵으로 표현할 수 잇는데, 결정적인 장점은 이거다.  요소를 움직일 때, 브라우저가 렌더링하면서 여러 파싱.. 렌더를 거치고 리페인트 리플로우를 일으키던 기존 방식과는 다르게 캔버스로 렌더링 한다는 건 이 과정을 싹 생략을 하는 것이다.
