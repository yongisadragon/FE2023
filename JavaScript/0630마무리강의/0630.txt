-margin collapsing 현상에 대해 서술하세요.
인접한 블록요소 간에
마진 바텀탑이 겹침

-사이에 요소
-pdding 1px
-inline block

bfc는 언제..
-button 태그와 input type=“button” 의 차이에 대해 설명하세요

button 태그 form태그로 submit할 수 있다.
인풋은 셀프클로징이라 컨텐츠를 넣을 수 없다.

-브라우저가 웹페이지를 렌더링하는 과정을 설명해주세요.(각 단계는 이전 단계의 데이터들이 필요)
1.파싱(html->DOM) js스크립트 만나면 멈춤
2.스타일 계산(CSS->CSSOM)
3.렌더트리 CSSOM으로 레이아웃트리(렌더트리)생성
4. 페인트 렌더트리를 따라 페인트 기록생성 -> 사용자들이 볼 수 있는 결과물
5. 컴포지팅

-브라우저 리플로우 현상에 대해 설명해 주세요.
브라우저는 html 구조가 변하거나, css를 통해 레이아웃이 변할떄, 리플로우-> 리페인트가 발생. 리플로우란 렌더트리를 재생성하는 작업. 그래서 애니메이션 또는 동적으로 요소의 위치를 이동해야하는 경우 transform사용.
왜 리플로우->리페인트인가?

즉 리플로우 현상이란 

브라우저 랜더링의 각 단계는 반드시 전 단계의 데이터가 필요하며, 
html의 레이아웃이 변경될 경우 레이아웃 단계에서 랜더 트리가 재생성되며 이를 리플로우라고 합니다.
레이아웃에 변화를 주는 거의 모든 속성이 리플로우를 유발합니다. 이를 피하기 위해 GPU를 이용하는 transform 속성을 이용하여 레이아웃을 제어하는게 좋습니다.

-클로져(Closure)는 무엇이며, 어떻게/왜 사용하는지 설명해주세요.

폐쇠된 공간의 데이터에 접근할 수 있는 테크닉
클로저는 중첩된 함수를 이용해 사용하는 방법이며 실행 컨택스트가 끝나도  변수에 접근 가능하게 해주는 기능입니다. 은닉이나 캡슐화로 정보를 보호할 때 그리고 비동기에서 사용됩니다.
내,외부함수
상위스코프의 변수를 기억하고 있다가 상위스코프가 사라져도 참조. 렉시컬스코프

클로저는 함수와 그 함수가 선언된 렉시컬 스코프의 조합. 클로저를 통해 함수는 자신이 생성될 당시 변수에 접근가능하며, 데이터 은닉화, 정보 보존, 콜백 함수등 다양한 용도..
단점. 렉시컬 스코프 변수를 계속 유지하기 때문에 필요 이상의 메모리.. 누수 특히 큰 데이터를 보존할 때.
불필요하게 오래 유지되는 경우, 해당 변수는 메모리에 해제되지 않을 수 있음.
성능 저하. 클로저는 변수에 접근하기 위해 스코프 체이닝이 필요. 일반적 함수호출보다 성능저하 이슈.. 복잡성과 가독성.. 

-호이스팅(hoisting)이란 무엇인가요?
자바스크립트에서 변수와 함수선언이 스코프의 최상단으로 끌어올려지는 것 처럼 보여지는 현상입니다 

변수와 함수를 선언하는 위치에 관계없이 JavaScript 엔진은 변수와 함수 선언을 스코프의 최상단으로 이동시키는 것처럼 작동합니다. 그러나 할당은 실제 코드 흐름에 따라 이루어집니다.

그러나 변수와 함수 선언에 let과 const가 사용된 경우에 이들은 TDZ(Temporal Dead Zone)라는 곳에 위치하게 되며, 실제 선언 위치 이전에는 접근할 수 없게됩니다.
변수가 선언된 시점과 초기화(첫 번째 할당)가 발생한 시점 사이의 공간을 의미합니다.

- 이벤트 캡쳐링과 버블링에 대해 설명해주세요.
이벤트가 발생했을 때, 캡처링이란 이벤트가 발생한 타깃 요소의 최상위 부모요소로부터 해당 요소를 탐색해 내려오며 이벤트 핸들러를 전부호출., 반대로 버블링은 발생한 요소로부터 최상위 요소로 이벤트가 전파되는 것

브라우저 화면에서 이벤트가 발생했을때 브라우저는 이벤트 대상을 찾아갑니다.
이때 상위의 window 객체부터 document, body 순으로 DOM 트리를 따라 내려갑니다. 이를 캡처링 단계라고 하며 중간에 만나는 모든 캡처링 이벤트 리스너를 실행시킵니다.
그리고 이벤트 대상을 찾고 캡처링이 끝나면 이제 다시 DOM 트리를 따라 올라가며 만나는 모든 버블링 이벤트 리스너를 실행합니다. 이를 이벤트 버블링 단계라고 합니다.
이러한 과정에서 이벤트 리스너가 차례로 실행되는것을 이벤트 전파(event propagation)라고 합니다.

브라우저가 이벤트 대상을 찾아갈 때는 가장 상위의 window 객체부터 document, body 순으로 DOM 트리를 따라 내려갑니다. 이를 캡처링 단계라고 합니다.
이때 이벤트 대상을 찾아가는 과정에서 브라우저는 중간에 만나는 모든 캡처링 이벤트 리스너를 실행시킵니다. 그리고 이벤트 대상을 찾고 캡처링이 끝나면 이제 다시 DOM 트리를 따라 올라가며 만나는 모든 버블링 이벤트 리스너를 실행합니다. 이를 이벤트 버블링 단계라고 합니다.
그리고 이러한 과정에서 이벤트 리스너가 차례로 실행되는것을 이벤트 전파(event propagation)라고 합니다.

-event delegation (이벤트 위임)에 관해 설명해주세요.
캡처버블링을 활용하여 하위요소에 각가 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식, 동적으로 추가되거나 제거되는 하위 요소들에 대한 이벤트 처리를 효율적으로 할 수 있습니다.

-setTimeout과 promise의 콜백함수가 있을 때 어떤게 먼저 실행되는가?
**스레드**(thread)는 어떠한 프로그램 내에서 실행되는 흐름의 단위를 말합니다.

일종의 컨베이어벨트라고 생각하면 쉽습니다!

-점진적 향상 기법이란 무엇인가요?
기본적으로 예전 기술 환경에서 동작할 수 있는 기능을 구현해두고, 최신 기술을 사용할 수 있는 환경에서는 최신 기술을 제공하여 더 나은 사용자 경험을 제공할 수 있는 방법.

-우아한 성능저하란(graceful degradation)?
최신 브라우저에서 최신 기술의 사용자 경험을 제공하지만 이전 브라우저에서는 더 낮은 수준의 사용자 경험으로 단계적으로 저하될 수 있도록 하는 방법입니다.

둘 다 최신 기술을 지원 하는 환경과 그렇지 못한 환경을 모두 대응 하려는 의도를 가지고 있는 방법론이지만 

점진적 향상은 기본적으로 제공하고자 하는 기능을 100%제공 하면서 최신 환경에서는 그 이상의 사용자 경험을 제공하려 합니다.

우아한 성능저하는 제공하고자 하는 기능이 100%라면 구형 환경에서는 그 기능의 일부라도 제공하여 기능 정지라는 최악의 사용자 경험을 회피하고자 하는 의도를 가집니다.

-<script>의 async 속성과 defer 속성의 차이에 대해 설명해주세요.
async는 스크립트를 다운로드됐을 때 곧바로 평가 실행하고 defer은 문서(HTML)을 완전히 다 읽은 후에 실행한다. async는 먼저 다운로드된 순서대로 실행하고 defer은 정의된 순서대로 실행된다.