비동기를 사용하는 경우
코드의 정확한 실행 시점을 알 수 없는 경우 (사용자 입력: 마우스, 인풋 이벤트 등)
처리에 시간이 많이 걸리는 동작의 경우 (네트워크 요청, 파일의 입출력 등)

JS는 싱글쓰레드로 동작. 그래서 위와 같은 처리가 필요한 경우, 처리되는 동안 다른 동작을 할 수 X. 어떻게 시간을 아끼면서 여러가지 일을 동시에 처리할 수 있을까?

일반적으로 비동기적으로 일을 처리한다면 더 빠르고 많은 일을 할 수 있습니다.

근데 비동기는 왜 어려움? XHL객체도, fetch까지도 통신 결과를 처리하는 방법이니까.. 괜찮다고 생각했을겁니다(그랬다고 칩시다). 하지만 어려운건 
보통의 동기식은
1. 값을 도출하고 함수 실행
2. 그 결과같을 변수에 저장
3. 변수에 접근해서 그 결과값을 이용

하지만 비동기식은 2,3번의 과정에서 문제가 발생한다. 3. 의 과정이 1,2의 과정을 기다려주지 않습니다. 그러면 비동기 동작을 동기식 '처럼' 코드를 작성하면 되지않음? 그래서 나온게 Promise객체이다.
1. 값을 도출하는 어떤 비동기식 함수 실행
2. 그 결과값을 변수에 저장하고
3. 변수에 저장하고 그 결과값을 이용

Promise는 크게 3가지 상태를 지니고, 비동기 함수의 결과를 처리합니당?
대기 pending
이행 fulfilled
거부 rejected
완료 finally (이행 거부 중 하나가 실행되고 무조건 실행되는 녀석)
프라미스 자체는 비동기가 아닙니다. 그냥 3가지 상태중 하나인 객체이다. 결국 목적 자체는 비동기 함수를 관찰하기 위해 탄생했다. 비동기 함수를 감싸고, 함수의 처리 결과로 단순한 데이터를 반환하는게 아니라. 프로미스 객체를 반환하게 만듭니다. 좋은점은, 비동기 함수의 결과로 undefined을 반환할 일이 없고, 프로미스 객체가 가지고 있는 then메서드 체이닝를 통해 비동기 함수를 동기적으로 처리합니다.

then은 사실 2개의 콜백함수 인자를 받을 수 있음.(각각 resolved, rejected) 둘다 then안에 있으면 헷갈리기 때문에 2번째 거절 인자가 catch로, 그것은 catch의 설탕함수로써 밖으로 나왔다고 보면된다.

결론 promise객체는 then메서드를 통해 비동기를 동기처럼 코드상에 보여지게 할 수 있다.

async-await는 promise의 설탕 문법임.. async 키워드가 함수 앞에 붙으면 함수가 Promise를 반환. 그리고 await는 promise를 반환할 때, 상태가 결정될때까지 다음 코드의 실행을 멈춤. 그리고 상태 결정나면 프라미스 객체의 fulfilled값을 반환함.